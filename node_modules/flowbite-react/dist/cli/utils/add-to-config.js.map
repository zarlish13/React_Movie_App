{"version":3,"file":"add-to-config.js","sources":["../../../src/cli/utils/add-to-config.ts"],"sourcesContent":["// eslint-disable-next-line @typescript-eslint/ban-ts-comment\n// @ts-nocheck\n\nimport { parse } from \"@typescript-eslint/typescript-estree\";\nimport * as recast from \"recast\";\n\n/**\n * Modifies the given content by adding a value to a specified path within the content.\n *\n * @param {Object} options - Options for adding a value to config.\n * @param {string} options.content - The content to modify.\n * @param {string} options.targetPath - The dot-separated path where the value will be added.\n * @param {Function} options.valueGenerator - Function that generates the AST node to be added.\n * @returns {string} The modified content with the added value.\n */\nexport function addToConfig({\n  content,\n  targetPath,\n  valueGenerator,\n}: {\n  content: string;\n  targetPath: string;\n  valueGenerator: (b: typeof recast.types.builders) => types.namedTypes.Expression;\n}): string {\n  const ast = recast.parse(content, {\n    parser: {\n      parse: (source: string) =>\n        parse(source, {\n          loc: true,\n          range: true,\n          tokens: true,\n          comment: true,\n        }),\n    },\n  });\n\n  // Store reference to config objects by their identifier names\n  const configMap = new Map<string, recast.types.namedTypes.ObjectExpression>();\n\n  recast.types.visit(ast, {\n    visitVariableDeclarator(path) {\n      const { node } = path;\n      // Store reference to the config object if found\n      if (\n        node.id.type === \"Identifier\" &&\n        node.init.type === \"CallExpression\" &&\n        node.init.callee.type === \"Identifier\" &&\n        node.init.arguments.length > 0 &&\n        node.init.arguments[0].type === \"ObjectExpression\"\n      ) {\n        configMap.set(node.id.name, node.init.arguments[0]);\n      } else if (node.id.type === \"Identifier\" && node.init.type === \"ObjectExpression\") {\n        configMap.set(node.id.name, node.init);\n      }\n      return false;\n    },\n\n    visitExportDefaultDeclaration(path) {\n      const { node } = path;\n      if (node.declaration.type === \"TSAsExpression\" || node.declaration.type === \"TSSatisfiesExpression\") {\n        // Handle both 'as' and 'satisfies' expressions by accessing their underlying expression\n        ensureArrayProperty(node.declaration.expression, targetPath, valueGenerator);\n      } else if (node.declaration.type === \"ObjectExpression\") {\n        // Handle direct object export: export default {}\n        ensureArrayProperty(node.declaration, targetPath, valueGenerator);\n      } else if (node.declaration.type === \"Identifier\") {\n        // Handle variable export: export default config\n        const configForId = configMap.get(node.declaration.name);\n        if (configForId) {\n          ensureArrayProperty(configForId, targetPath, valueGenerator);\n        }\n      } else if (\n        node.declaration.type === \"CallExpression\" &&\n        node.declaration.callee.type === \"Identifier\" &&\n        node.declaration.arguments.length > 0\n      ) {\n        // Handle function call exports like defineConfig(viteConfig)\n        const arg = node.declaration.arguments[0];\n        if (arg.type === \"ObjectExpression\") {\n          ensureArrayProperty(arg, targetPath, valueGenerator);\n        } else if (arg.type === \"Identifier\") {\n          const configForId = configMap.get(arg.name);\n          if (configForId) {\n            ensureArrayProperty(configForId, targetPath, valueGenerator);\n          }\n        }\n      }\n      return false;\n    },\n\n    visitAssignmentExpression(path) {\n      const { node } = path;\n      if (\n        node.left.type === \"MemberExpression\" &&\n        node.left.object.type === \"Identifier\" &&\n        node.left.object.name === \"module\" &&\n        node.left.property.type === \"Identifier\" &&\n        node.left.property.name === \"exports\"\n      ) {\n        if (node.right.type === \"ObjectExpression\") {\n          // Direct object assignment: module.exports = {}\n          ensureArrayProperty(node.right, targetPath, valueGenerator);\n        } else if (node.right.type === \"Identifier\") {\n          // Variable assignment: module.exports = config\n          const configForId = configMap.get(node.right.name);\n          if (configForId) {\n            ensureArrayProperty(configForId, targetPath, valueGenerator);\n          }\n        } else if (\n          node.right.type === \"CallExpression\" &&\n          node.right.arguments.length > 0 &&\n          node.right.arguments[0].type === \"ObjectExpression\"\n        ) {\n          // Handle function call with object argument for module.exports\n          ensureArrayProperty(node.right.arguments[0], targetPath, valueGenerator);\n        }\n      }\n      return false;\n    },\n  });\n\n  return recast.print(ast).code;\n}\n\n/**\n * Ensures that a given nested path exists and appends a value to an array.\n *\n * @param {object} objExpr - The ObjectExpression AST node.\n * @param {string} path - The dot-separated path (e.g., \"vite.plugins\").\n * @param {Function} valueGenerator - Function that generates the AST node to be added.\n */\nfunction ensureArrayProperty(\n  objExpr: recast.types.namedTypes.ObjectExpression,\n  path: string,\n  valueGenerator: (b: typeof recast.types.builders) => recast.types.namedTypes.Expression,\n): void {\n  const b = recast.types.builders;\n  const keys = path.split(\".\");\n  let current = objExpr;\n\n  // Create or traverse to each level of the path\n  for (let i = 0; i < keys.length; i++) {\n    const key = keys[i];\n    let prop = current.properties.find((p) => {\n      if (p.type !== \"Property\") return false;\n      const propKey = p.key;\n      return (\n        (propKey.type === \"Identifier\" && propKey.name === key) || (propKey.type === \"Literal\" && propKey.value === key)\n      );\n    });\n\n    if (!prop) {\n      // Create new property with appropriate value\n      const value = i === keys.length - 1 ? b.arrayExpression([]) : b.objectExpression([]);\n      prop = b.property(\"init\", b.identifier(key), value);\n      current.properties.push(prop);\n    }\n\n    if (prop.type === \"Property\") {\n      // Handle the case where the value is a chained array method\n      if (i === keys.length - 1 && prop.value.type === \"CallExpression\") {\n        const currentExpr = prop.value;\n        // Walk up the chain of method calls to find the original array\n        while (\n          currentExpr.type === \"CallExpression\" &&\n          currentExpr.callee.type === \"MemberExpression\" &&\n          currentExpr.callee.object.type === \"ArrayExpression\"\n        ) {\n          current = currentExpr.callee.object;\n          break;\n        }\n        if (current !== objExpr) {\n          continue;\n        }\n      }\n\n      // Ensure the value is an object expression if we're not at the end\n      if (i < keys.length - 1 && prop.value.type !== \"ObjectExpression\") {\n        prop.value = b.objectExpression([]);\n      }\n      // Ensure the value is an array expression if we're at the end\n      else if (i === keys.length - 1 && prop.value.type !== \"ArrayExpression\") {\n        prop.value = b.arrayExpression([]);\n      }\n      current = prop.value;\n    }\n  }\n\n  // Add the value if it doesn't already exist\n  if (current.type === \"ArrayExpression\") {\n    const value = valueGenerator(b);\n\n    // Check if the value already exists\n    const exists = current.elements.some((el) => {\n      if (!el) return false;\n\n      // Both Literal and StringLiteral types have a 'value' property for string values\n      if (\n        (el.type === \"StringLiteral\" || el.type === \"Literal\") &&\n        (value.type === \"StringLiteral\" || value.type === \"Literal\") &&\n        typeof el.value === \"string\" &&\n        typeof value.value === \"string\"\n      ) {\n        return el.value === value.value;\n      }\n\n      // For function calls, compare the function names\n      if (\n        el.type === \"CallExpression\" &&\n        value.type === \"CallExpression\" &&\n        el.callee?.type === \"Identifier\" &&\n        value.callee?.type === \"Identifier\"\n      ) {\n        return el.callee.name === value.callee.name;\n      }\n\n      // For identifiers, compare their names\n      if (el.type === \"Identifier\" && value.type === \"Identifier\") {\n        return el.name === value.name;\n      }\n\n      return false;\n    });\n\n    if (!exists) {\n      current.elements.push(value);\n    }\n  }\n}\n"],"names":[],"mappings":"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"}