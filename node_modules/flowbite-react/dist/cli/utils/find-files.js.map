{"version":3,"file":"find-files.js","sources":["../../../src/cli/utils/find-files.ts"],"sourcesContent":["import fs from \"fs/promises\";\nimport path from \"path\";\n\nexport interface FindFilesOptions {\n  patterns: string[];\n  startDir?: string;\n  excludeDirs?: string[];\n  parallel?: boolean;\n  recursive?: boolean;\n}\n\n/**\n * Finds files matching specified patterns within a directory.\n *\n * This function recursively searches a directory for files that match the given patterns.\n * It can be configured to search in parallel or sequentially, and to exclude specific directories.\n *\n * @param {FindFilesOptions} options - The options for the file search.\n * @param {string[]} options.patterns - The patterns to match files against.\n * @param {string} [options.startDir=\".\"] - The directory to start the search from.\n * @param {string[]} [options.excludeDirs=[]] - Directories to exclude from the search.\n * @param {boolean} [options.parallel=true] - Whether to search in parallel or sequentially.\n * @param {boolean} [options.recursive=true] - Whether to search recursively.\n * @returns {Promise<string[]>} A promise that resolves to an array of paths of files that match the patterns.\n */\nexport async function findFiles({\n  patterns,\n  startDir = \".\",\n  excludeDirs = [],\n  parallel = true,\n  recursive = true,\n}: FindFilesOptions): Promise<string[]> {\n  const results: string[] = [];\n\n  // Helper function to check if the file matches a pattern\n  function matchesPattern(fileName: string): boolean {\n    return patterns.some((pattern) => {\n      // Check if the pattern contains a wildcard and match extensions\n      const patternParts = pattern.split(\"/\");\n      const patternFileName = patternParts[patternParts.length - 1];\n\n      // Check if pattern has no wildcards (*), i.e., exact file name match\n      if (patternFileName && !patternFileName.includes(\"*\")) {\n        return fileName === patternFileName; // Exact match for filenames like 'tailwind.config.js'\n      }\n\n      // If pattern includes wildcard, we match extensions (e.g., **/*.js, **/*.css)\n      const fileExt = path.extname(fileName).slice(1); // Get file extension (e.g., js, ts)\n      const patternExt = patternFileName.split(\".\").pop();\n\n      return patternFileName.includes(\"*\") && patternExt === fileExt;\n    });\n  }\n\n  // Recursive search function\n  async function search(directory: string): Promise<void> {\n    // Skip excluded directories\n    if (excludeDirs.includes(path.basename(directory))) {\n      return;\n    }\n\n    try {\n      const entries = await fs.readdir(directory, { withFileTypes: true });\n      const tasks = entries.map(async (entry) => {\n        const fullPath = path.join(directory, entry.name);\n\n        if (entry.isDirectory()) {\n          if (recursive) {\n            return search(fullPath); // Recursive call for directories\n          }\n        } else {\n          // Check if file matches the pattern\n          if (matchesPattern(entry.name)) {\n            results.push(fullPath); // Add matching file to results\n          }\n        }\n      });\n\n      // Control parallelism\n      if (parallel) {\n        await Promise.all(tasks); // Run directory/file checks in parallel\n      } else {\n        for (const task of tasks) {\n          await task; // Run directory/file checks sequentially\n        }\n      }\n    } catch (error) {\n      console.error(\"Error reading directory:\", error);\n    }\n  }\n\n  await search(startDir);\n  return results;\n}\n"],"names":["path","fs"],"mappings":";;;AAGO,eAAe,SAAS,CAAC;AAChC,EAAE,QAAQ;AACV,EAAE,QAAQ,GAAG,GAAG;AAChB,EAAE,WAAW,GAAG,EAAE;AAClB,EAAE,QAAQ,GAAG,IAAI;AACjB,EAAE,SAAS,GAAG;AACd,CAAC,EAAE;AACH,EAAE,MAAM,OAAO,GAAG,EAAE;AACpB,EAAE,SAAS,cAAc,CAAC,QAAQ,EAAE;AACpC,IAAI,OAAO,QAAQ,CAAC,IAAI,CAAC,CAAC,OAAO,KAAK;AACtC,MAAM,MAAM,YAAY,GAAG,OAAO,CAAC,KAAK,CAAC,GAAG,CAAC;AAC7C,MAAM,MAAM,eAAe,GAAG,YAAY,CAAC,YAAY,CAAC,MAAM,GAAG,CAAC,CAAC;AACnE,MAAM,IAAI,eAAe,IAAI,CAAC,eAAe,CAAC,QAAQ,CAAC,GAAG,CAAC,EAAE;AAC7D,QAAQ,OAAO,QAAQ,KAAK,eAAe;AAC3C;AACA,MAAM,MAAM,OAAO,GAAGA,aAAI,CAAC,OAAO,CAAC,QAAQ,CAAC,CAAC,KAAK,CAAC,CAAC,CAAC;AACrD,MAAM,MAAM,UAAU,GAAG,eAAe,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC,GAAG,EAAE;AACzD,MAAM,OAAO,eAAe,CAAC,QAAQ,CAAC,GAAG,CAAC,IAAI,UAAU,KAAK,OAAO;AACpE,KAAK,CAAC;AACN;AACA,EAAE,eAAe,MAAM,CAAC,SAAS,EAAE;AACnC,IAAI,IAAI,WAAW,CAAC,QAAQ,CAACA,aAAI,CAAC,QAAQ,CAAC,SAAS,CAAC,CAAC,EAAE;AACxD,MAAM;AACN;AACA,IAAI,IAAI;AACR,MAAM,MAAM,OAAO,GAAG,MAAMC,WAAE,CAAC,OAAO,CAAC,SAAS,EAAE,EAAE,aAAa,EAAE,IAAI,EAAE,CAAC;AAC1E,MAAM,MAAM,KAAK,GAAG,OAAO,CAAC,GAAG,CAAC,OAAO,KAAK,KAAK;AACjD,QAAQ,MAAM,QAAQ,GAAGD,aAAI,CAAC,IAAI,CAAC,SAAS,EAAE,KAAK,CAAC,IAAI,CAAC;AACzD,QAAQ,IAAI,KAAK,CAAC,WAAW,EAAE,EAAE;AACjC,UAAU,IAAI,SAAS,EAAE;AACzB,YAAY,OAAO,MAAM,CAAC,QAAQ,CAAC;AACnC;AACA,SAAS,MAAM;AACf,UAAU,IAAI,cAAc,CAAC,KAAK,CAAC,IAAI,CAAC,EAAE;AAC1C,YAAY,OAAO,CAAC,IAAI,CAAC,QAAQ,CAAC;AAClC;AACA;AACA,OAAO,CAAC;AACR,MAAM,IAAI,QAAQ,EAAE;AACpB,QAAQ,MAAM,OAAO,CAAC,GAAG,CAAC,KAAK,CAAC;AAChC,OAAO,MAAM;AACb,QAAQ,KAAK,MAAM,IAAI,IAAI,KAAK,EAAE;AAClC,UAAU,MAAM,IAAI;AACpB;AACA;AACA,KAAK,CAAC,OAAO,KAAK,EAAE;AACpB,MAAM,OAAO,CAAC,KAAK,CAAC,0BAA0B,EAAE,KAAK,CAAC;AACtD;AACA;AACA,EAAE,MAAM,MAAM,CAAC,QAAQ,CAAC;AACxB,EAAE,OAAO,OAAO;AAChB;;;;"}