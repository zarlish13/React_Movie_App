'use strict';

var fs = require('fs/promises');
var path = require('path');

var _documentCurrentScript = typeof document !== 'undefined' ? document.currentScript : null;
async function patchTailwind() {
  try {
    let tailwindPath;
    try {
      let tailwindModulePath;
      if (typeof require !== "undefined") {
        tailwindModulePath = require.resolve("tailwindcss/package.json", {
          paths: [process.cwd()]
        });
        tailwindPath = path.resolve(path.dirname(tailwindModulePath));
      } else {
        const { createRequire } = await import('module');
        const require2 = createRequire((typeof document === 'undefined' ? require('u' + 'rl').pathToFileURL(__filename).href : (_documentCurrentScript && _documentCurrentScript.tagName.toUpperCase() === 'SCRIPT' && _documentCurrentScript.src || new URL('cli/commands/patch.cjs', document.baseURI).href)));
        tailwindModulePath = require2.resolve("tailwindcss/package.json", {
          paths: [process.cwd()]
        });
        tailwindPath = path.resolve(path.dirname(tailwindModulePath));
      }
    } catch {
      console.warn("Could not resolve Tailwind CSS module path. Skipping version patch.");
      return;
    }
    const tailwindPackageJsonPath = path.join(tailwindPath, "package.json");
    let tailwindPackageJson;
    try {
      const packageJsonContent = await fs.readFile(tailwindPackageJsonPath, "utf-8");
      tailwindPackageJson = JSON.parse(packageJsonContent);
    } catch {
      console.warn("Could not read Tailwind CSS `package.json`. Skipping version patch.");
      return;
    }
    const actualVersion = tailwindPackageJson.version;
    const versionFilePath = path.join(tailwindPath, "version.js");
    const versionMjsFilePath = path.join(tailwindPath, "version.mjs");
    const versionDtsFilePath = path.join(tailwindPath, "version.d.ts");
    const versionDmtsFilePath = path.join(tailwindPath, "version.d.mts");
    let patchesApplied = false;
    try {
      let filesCreated = false;
      if (await shouldUpdateFile(versionFilePath, actualVersion)) {
        const versionContent = `"use strict";

const version = "${actualVersion}";
module.exports = version;
`;
        await fs.writeFile(versionFilePath, versionContent, "utf-8");
        filesCreated = true;
      }
      if (await shouldUpdateFile(versionMjsFilePath, actualVersion)) {
        const versionMjsContent = `const version = "${actualVersion}";
export default version;
`;
        await fs.writeFile(versionMjsFilePath, versionMjsContent, "utf-8");
        filesCreated = true;
      }
      if (await shouldUpdateFile(versionDtsFilePath)) {
        const versionDtsContent = `declare const version: string;
export = version;
`;
        await fs.writeFile(versionDtsFilePath, versionDtsContent, "utf-8");
        filesCreated = true;
      }
      if (await shouldUpdateFile(versionDmtsFilePath)) {
        const versionDmtsContent = `declare const version: string;
export default version;
`;
        await fs.writeFile(versionDmtsFilePath, versionDmtsContent, "utf-8");
        filesCreated = true;
      }
      if (filesCreated) {
        patchesApplied = true;
      }
    } catch {
      console.warn("Could not create Tailwind CSS version files. Skipping version patch.");
    }
    try {
      if (tailwindPackageJson.exports) {
        if (!tailwindPackageJson.exports["./version"] || !tailwindPackageJson.exports["./version.js"]) {
          tailwindPackageJson.exports = {
            ...tailwindPackageJson.exports,
            "./version": {
              require: "./version.js",
              import: "./version.mjs"
            },
            "./version.js": {
              require: "./version.js",
              import: "./version.mjs"
            }
          };
          await fs.writeFile(tailwindPackageJsonPath, JSON.stringify(tailwindPackageJson, null, 2), "utf-8");
          patchesApplied = true;
        }
      }
    } catch {
      console.warn("Could not patch Tailwind CSS `package.json.exports`. Skipping version patch.");
    }
    if (patchesApplied) {
      console.log("Patched Tailwind CSS");
    }
  } catch (error) {
    console.error("Failed to patch Tailwind CSS:", error);
  }
}
async function shouldUpdateFile(filePath, actualVersion) {
  try {
    const content = await fs.readFile(filePath, "utf-8");
    if (actualVersion !== void 0) {
      return !content.includes(actualVersion);
    }
    return false;
  } catch {
    return true;
  }
}

exports.patchTailwind = patchTailwind;
//# sourceMappingURL=patch.cjs.map
